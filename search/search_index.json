{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"zend-expressive-authorization-rbac Repository abandoned 2019-12-31 This repository has moved to mezzio/mezzio-authorization-rbac . This library provides a zend-rbac adapter for zend-expressive-authorization. Installation Run the following to install this library: $ composer require zendframework/zend-expressive-authorization-rbac Documentation Documentation is in the doc tree , and can be compiled using mkdocs : $ mkdocs build You may also browse the documentation online .","title":"Home"},{"location":"#zend-expressive-authorization-rbac","text":"","title":"zend-expressive-authorization-rbac"},{"location":"#repository-abandoned-2019-12-31","text":"This repository has moved to mezzio/mezzio-authorization-rbac . This library provides a zend-rbac adapter for zend-expressive-authorization.","title":"Repository abandoned 2019-12-31"},{"location":"#installation","text":"Run the following to install this library: $ composer require zendframework/zend-expressive-authorization-rbac","title":"Installation"},{"location":"#documentation","text":"Documentation is in the doc tree , and can be compiled using mkdocs : $ mkdocs build You may also browse the documentation online .","title":"Documentation"},{"location":"v1/dynamic-assertion/","text":"Dynamic Assertion In some cases you will need to authorize a role based on a specific HTTP request. For instance, imagine that you have an \"editor\" role that can add/update/delete a page in a Content Management System (CMS). We want to prevent an \"editor\" from modifying pages they have not created. These types of authorization are called dynamic assertions and are implemented via the Zend\\Permissions\\Rbac\\AssertionInterface of zend-permissions-rbac . In order to use it, this package provides ZendRbacAssertionInterface , which extends Zend\\Permissions\\Rbac\\AssertionInterface : namespace Zend\\Expressive\\Authorization\\Rbac; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Permissions\\Rbac\\AssertionInterface; interface ZendRbacAssertionInterface extends AssertionInterface { public function setRequest(ServerRequestInterface $request) : void; } The Zend\\Permissions\\Rbac\\AssertionInterface defines the following: namespace Zend\\Permissions\\Rbac; interface AssertionInterface { public function assert(Rbac $rbac, RoleInterface $role, string $permission) : bool; } Going back to our use case, we can build a class to manage the \"editor\" authorization requirements, as follows: use Zend\\Expressive\\Authorization\\Rbac\\ZendRbacAssertionInterface; use App\\Service\\Article; class EditorAuth implements ZendRbacAssertionInterface { public function __construct(Article $article) { $this->article = $article; } public function setRequest(ServerRequestInterface $request) { $this->request = $request; } public function assert(Rbac $rbac, RoleInterface $role, string $permission) { $user = $this->request->getAttribute(UserInterface::class, false); return $this->article->isUserOwner($user->getIdentity(), $this->request); } } Where Article is a class that checks if the identified user is the owner of the article referenced in the HTTP request. If you manage articles using a SQL database, the implementation of isUserOwner() might look like the following: public function isUserOwner(string $identity, ServerRequestInterface $request): bool { // get the article {article_id} attribute specified in the route $url = $request->getAttribute('article_id', false); if (! $url) { return false; } $sth = $this->pdo->prepare( 'SELECT * FROM article WHERE url = :url AND owner = :identity' ); $sth->bindParam(':url', $url); $sth->bindParam(':identity', $identity); if (! $sth->execute()) { return false; } $row = $sth->fetch(); return ! empty($row); } To pass the Article dependency to your assertion, you can use a Factory class that generates the EditorAuth class instance, as follows: use App\\Service\\Article; class EditorAuthFactory { public function __invoke(ContainerInterface $container) : EditorAuth { return new EditorAuth( $container->get(Article::class) ); } } And configure the service container to use EditorAuthFactory to point to EditorAuth , using the following configuration: return [ 'dependencies' => [ 'factories' => [ // ... EditorAuth::class => EditorAuthFactory::class ] ] ];","title":"Dynamic Assertion"},{"location":"v1/dynamic-assertion/#dynamic-assertion","text":"In some cases you will need to authorize a role based on a specific HTTP request. For instance, imagine that you have an \"editor\" role that can add/update/delete a page in a Content Management System (CMS). We want to prevent an \"editor\" from modifying pages they have not created. These types of authorization are called dynamic assertions and are implemented via the Zend\\Permissions\\Rbac\\AssertionInterface of zend-permissions-rbac . In order to use it, this package provides ZendRbacAssertionInterface , which extends Zend\\Permissions\\Rbac\\AssertionInterface : namespace Zend\\Expressive\\Authorization\\Rbac; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Permissions\\Rbac\\AssertionInterface; interface ZendRbacAssertionInterface extends AssertionInterface { public function setRequest(ServerRequestInterface $request) : void; } The Zend\\Permissions\\Rbac\\AssertionInterface defines the following: namespace Zend\\Permissions\\Rbac; interface AssertionInterface { public function assert(Rbac $rbac, RoleInterface $role, string $permission) : bool; } Going back to our use case, we can build a class to manage the \"editor\" authorization requirements, as follows: use Zend\\Expressive\\Authorization\\Rbac\\ZendRbacAssertionInterface; use App\\Service\\Article; class EditorAuth implements ZendRbacAssertionInterface { public function __construct(Article $article) { $this->article = $article; } public function setRequest(ServerRequestInterface $request) { $this->request = $request; } public function assert(Rbac $rbac, RoleInterface $role, string $permission) { $user = $this->request->getAttribute(UserInterface::class, false); return $this->article->isUserOwner($user->getIdentity(), $this->request); } } Where Article is a class that checks if the identified user is the owner of the article referenced in the HTTP request. If you manage articles using a SQL database, the implementation of isUserOwner() might look like the following: public function isUserOwner(string $identity, ServerRequestInterface $request): bool { // get the article {article_id} attribute specified in the route $url = $request->getAttribute('article_id', false); if (! $url) { return false; } $sth = $this->pdo->prepare( 'SELECT * FROM article WHERE url = :url AND owner = :identity' ); $sth->bindParam(':url', $url); $sth->bindParam(':identity', $identity); if (! $sth->execute()) { return false; } $row = $sth->fetch(); return ! empty($row); } To pass the Article dependency to your assertion, you can use a Factory class that generates the EditorAuth class instance, as follows: use App\\Service\\Article; class EditorAuthFactory { public function __invoke(ContainerInterface $container) : EditorAuth { return new EditorAuth( $container->get(Article::class) ); } } And configure the service container to use EditorAuthFactory to point to EditorAuth , using the following configuration: return [ 'dependencies' => [ 'factories' => [ // ... EditorAuth::class => EditorAuthFactory::class ] ] ];","title":"Dynamic Assertion"},{"location":"v1/intro/","text":"Introduction This component provides Role-Based Access Control (RBAC) authorization abstraction for the zend-expressive-authorization library. RBAC is based on the idea of roles . In a web application, users have an identity (e.g. username, email, etc). Each identified user then has one or more roles (e.g. admin, editor, guest). Each role has a permission to perform one or more actions (e.g. access an URL, execute specific web API calls). In a typical RBAC system: An identity has one or more roles. A role requests access to a permission. A permission is given to a role. Thus, RBAC has the following model: Many-to-many relationship between identities and roles. Many-to-many relationship between roles and permissions. Roles can have a parent role. The first requirement for an RBAC system is identities . In our scenario, the users are generated by an authentication system, provided by zend-expressive-authentication . That library provides a PSR-7 request attribute named Zend\\Expressive\\Authentication\\UserInterface when a user is authenticated. The RBAC system uses this instance to get information about the user's identity. Configure an RBAC system You can configure your RBAC using a configuration file, as follows: // config/autoload/authorization.local.php return [ // ... 'zend-expressive-authorization-rbac' => [ 'roles' => [ 'administrator' => [], 'editor' => ['administrator'], 'contributor' => ['editor'], ], 'permissions' => [ 'contributor' => [ 'admin.dashboard', 'admin.posts', ], 'editor' => [ 'admin.publish', ], 'administrator' => [ 'admin.settings', ], ], ] ]; In the above example, we designed an RBAC system with 3 roles: administator , editor , and contributor . We defined a hierarchy of roles as follows: administrator has no parent role. editor has administrator as a parent. That means administrator inherits the permissions of the editor . contributor has editor as a parent. That means editor inherits the permissions of contributor , and following the chain, administator inherits the permissions of contributor . For each role, we specified an array of permissions. As you can notice, a permission is just a string; it can represent anything. In our implementation, this string represents a route name. That means the contributor role can access the routes admin.dashboard and admin.posts but cannot access the routes admin.publish (assigned to editor role) and admin.settings (assigned to administrator ). If you want to change the authorization logic for each permission, you can write your own Zend\\Expressive\\Authorization\\AuthorizationInterface implementation. That interface defines the following method: isGranted(string $role, ServerRequestInterface $request) : bool where $role is the role and $request is the PSR-7 HTTP request to authorize. This library uses the zendframework/zend-permissions-rbac library to implement the RBAC system. If you want to know more about the usage of this library, read the blog post Manage permissions with zend-permissions-rbac .","title":"Introduction"},{"location":"v1/intro/#introduction","text":"This component provides Role-Based Access Control (RBAC) authorization abstraction for the zend-expressive-authorization library. RBAC is based on the idea of roles . In a web application, users have an identity (e.g. username, email, etc). Each identified user then has one or more roles (e.g. admin, editor, guest). Each role has a permission to perform one or more actions (e.g. access an URL, execute specific web API calls). In a typical RBAC system: An identity has one or more roles. A role requests access to a permission. A permission is given to a role. Thus, RBAC has the following model: Many-to-many relationship between identities and roles. Many-to-many relationship between roles and permissions. Roles can have a parent role. The first requirement for an RBAC system is identities . In our scenario, the users are generated by an authentication system, provided by zend-expressive-authentication . That library provides a PSR-7 request attribute named Zend\\Expressive\\Authentication\\UserInterface when a user is authenticated. The RBAC system uses this instance to get information about the user's identity.","title":"Introduction"},{"location":"v1/intro/#configure-an-rbac-system","text":"You can configure your RBAC using a configuration file, as follows: // config/autoload/authorization.local.php return [ // ... 'zend-expressive-authorization-rbac' => [ 'roles' => [ 'administrator' => [], 'editor' => ['administrator'], 'contributor' => ['editor'], ], 'permissions' => [ 'contributor' => [ 'admin.dashboard', 'admin.posts', ], 'editor' => [ 'admin.publish', ], 'administrator' => [ 'admin.settings', ], ], ] ]; In the above example, we designed an RBAC system with 3 roles: administator , editor , and contributor . We defined a hierarchy of roles as follows: administrator has no parent role. editor has administrator as a parent. That means administrator inherits the permissions of the editor . contributor has editor as a parent. That means editor inherits the permissions of contributor , and following the chain, administator inherits the permissions of contributor . For each role, we specified an array of permissions. As you can notice, a permission is just a string; it can represent anything. In our implementation, this string represents a route name. That means the contributor role can access the routes admin.dashboard and admin.posts but cannot access the routes admin.publish (assigned to editor role) and admin.settings (assigned to administrator ). If you want to change the authorization logic for each permission, you can write your own Zend\\Expressive\\Authorization\\AuthorizationInterface implementation. That interface defines the following method: isGranted(string $role, ServerRequestInterface $request) : bool where $role is the role and $request is the PSR-7 HTTP request to authorize. This library uses the zendframework/zend-permissions-rbac library to implement the RBAC system. If you want to know more about the usage of this library, read the blog post Manage permissions with zend-permissions-rbac .","title":"Configure an RBAC system"}]}